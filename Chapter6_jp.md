## VI. Large-scale Structure for Strategic Design

設計全体にわたるパターンでの要素の役割に関して要素を解釈できるようにするための包括的な原則がない大規模システムでは、開発者は状況の把握が困難になります。 私達は全体の細部を掘り下げることなく、全体の中で個々の部分が果たす役割を理解できなければなりません。

「大規模構造」とは、システムを大まかに話し合って理解できる言語です。一連の高レベルの概念またはルール、あるいはその両方により、システム全体の設計パターンが確立されます。この組織化の原則は、設計の指針となり、理解を助けることができます。さまざまな部分の役割が全体をどのように形成するかという、全体像の共通概念があるため、独立した作業の調整に役立ちます。

Therefore:

__システム全体にまたがるルールまたはロールおよび関係のパターンを考案します。これにより、部品の責任に関する詳細な知識がなくても、各部品の全体的な位置をある程度理解できます。__

### Evolving Order

すべてを自由に設計することは、誰もが全体として意味をなさないシステムを生み出し、それらを維持することは非常に困難です。 しかし、アーキテクチャは、設計の前提条件を前もってプロジェクトに拘束し、アプリケーションの特定の部分の開発者/設計者からあまりにも多くの力を奪う可能性があります。 すぐに、開発者はアプリケーションを構造に合わせてダムダウンするか、構造を破壊してまったく構造を持たなくなり、調整されていない開発の問題を取り戻します。

Therefore:

__この概念的な大規模構造をアプリケーションとともに進化させ、途中で完全に異なるタイプの構造に変更する可能性があります。 詳細な知識で行わなければならない詳細な設計とモデルの決定を過度に制約しないでください。__

__モデル開発に不自然な制約を強いることなく、システムを大幅に明確化する構造が見つかった場合、大規模構造を適用する必要があります。不適切な構造はどれよりも悪いので、包括性を求めて撮影するのではなく、出現した問題を解決する最小限のセットを見つけることが最善です。少ないほうがいい。__

__以下は、いくつかのプロジェクトで出現し、この種のパターンを代表する大規模構造の4つの特定のパターンのセットです。__

### System Metaphor

メタファー的思考は、ソフトウェア開発、特にモデルで普及しています。 しかし、「メタファー」のエクストリームプログラミングプラクティスは、システム全体の開発に秩序をもたらすためにメタファーを使用する特定の方法を意味するようになりました。

ソフトウェア設計は非常に抽象的で、把握するのが難しい傾向があります。 開発者もユーザーも、システムを理解し、システム全体のビューを共有するための具体的な方法を必要としています。

Therefore:

__システムへの具体的なアナロジーが現れ、チームメンバーの想像力を捉え、有用な方向に思考を導くように思われる場合、それを大規模な構造として採用します。 このメタファーを中心にデザインを整理し、ユビキタス言語に吸収します。 システムのメタファーは、システムに関するコミュニケーションを促進し、システムの開発をガイドする必要があります。 これにより、システムのさまざまな部分で、場合によってはさまざまな境界のあるコンテキスト全体で一貫性が高まります。 しかし、すべてのメタファーは不正確であるため、過剰な拡張や不適当さのために絶えずメタファーを再検査し、邪魔になったらそれを落とす準備をしてください。__

### Responsibility Layers

オブジェクト指向設計では、個々のオブジェクトに関連する一連の狭い責任が割り当てられます。 責任主導型の設計は、大規模にも適用されます。

個々のオブジェクトに手作りの責任がある場合、ガイドラインも、均一性も、ドメインの大きな帯を一緒に処理する能力もありません。 大規模モデルに一貫性を持たせるには、これらの責任の割り当てに何らかの構造を課すことが有用です。

Therefore:

__モデルの概念的な依存関係と、ドメインのさまざまな部分の変化の速度と変化の原因を見てください。 ドメイン内の自然の層を特定する場合、それらを広範な抽象的な責任としてキャストします。 これらの責任は、システムの高レベルの目的と設計のストーリーを伝える必要があります。 モデルをリファクタリングして、各ドメインオブジェクト、集合体、およびモジュールの責任が1つのレイヤーの責任にきちんと収まるようにします。__

### Knowledge Level

オブジェクトの別のグループの動作方法を記述するオブジェクトのグループ。

エンティティ間の役割と関係が異なる状況で異なるアプリケーションでは、複雑さが爆発する可能性があります。 完全に一般的なモデルも高度にカスタマイズされたモデルも、ユーザーのニーズを満たしません。 オブジェクトは、さまざまなケースに対応するために他のタイプへの参照、またはさまざまな状況でさまざまな方法で使用される属性値になります。 同じデータと動作を持つクラスは、異なるアセンブリ規則に対応するためだけに増加する場合があります。

Therefore:

__基本モデルの構造と動作を記述および制約するために使用できるオブジェクトの個別のセットを作成します。 これらの懸念を2つの「レベル」に分けてください。1つは非常に具体的なもので、もう1つはユーザーまたはスーパーユーザーがカスタマイズできるルールと知識を反映しています。__

_(see Fowler, M. 1997. Analysis Patterns: Reusable Object Models, Addison-Wesley.)_

### Pluggable Component Framework

機会は、深くて蒸留された非常に成熟したモデルで生じます。 プラガブルコンポーネントフレームワークは、通常、いくつかのアプリケーションが同じドメインに既に実装されている場合にのみ機能します。

さまざまなアプリケーションを相互運用する必要がある場合、それらはすべて同じ抽象化に基づいているが独立して設計されているため、複数の境界コンテキスト間の変換により統合が制限されます。 共有カーネルは、密接に連携していないチームには適していません。 複製と断片化は、開発とインストールのコストを引き上げ、相互運用性は非常に困難になります。

Therefore:

__インターフェースとインタラクションの抽象的なコアを蒸留し、これらのインターフェースのさまざまな実装を自由に置き換えることができるフレームワークを作成します。 同様に、抽象コアのインターフェースを介して厳密に動作する限り、すべてのアプリケーションがこれらのコンポーネントを使用できるようにします。__
