## II. Building Blocks of a Model-Driven Design

これらのパターンは、ドメイン駆動設計に照らして、広く行われているオブジェクト指向設計のベストプラクティスを反映しています。これらはモデルを明確にし、モデルと実装を互いに整合させ、互いの効果を強化するための結論へと導きます。個々のモデル要素の詳細を慎重に作成することで、開発者はモデルを探索し、それらを実装と密接に対応させるための安定したプラットフォームを得ることができます。

### Layered Architecture

オブジェクト指向プログラムでは、UI、データベース、およびその他の補助的なコードは、ビジネスオブジェクトに直接書き込まれることがよくあります。追加のビジネスロジックは、UIウィジェットおよびデータベーススクリプトの動作に組み込まれます。このような方法は、短期的には、プログラムを動作させるのに最も簡単であるために行われます。

このように、ドメイン関連のコードが大量の他のコードの中で散乱すると、見辛く、読み取りが非常に困難になります。 UIに対する表面的な変更が、実際にはビジネスロジックを変更してしまうかもしれません。ビジネスルールを変更するには、UIコード、データベースコード、またはその他のプログラム要素を綿密にトレースする必要があります。首尾一貫したモデル駆動型のオブジェクトを実装することが現実的ではなくなってしまいます。自動テストが扱いにくくなります。それぞれの活動に関わるすべての技術と論理で、プログラムは非常に単純に保たれなければならなりません。さもなければ、理解するのが不可能になります。

したがって:

__ドメインモデルとビジネスロジックの表現を分離し、ビジネスロジックではないインフラストラクチャ、ユーザーインターフェイス、アプリケーションロジックへの依存を排除しましょう。複雑なプログラムを複数のレイヤーに分割します。各レイヤーは、レイヤーの中で凝縮した、下のレイヤーにのみ依存する設計にしましょう。 スタンダードなアーキテクチャパターンに従って、上のレイヤーとの疎結合を実現します。ドメインモデルに関連するすべてのコードを単一のレイヤーに集中させ、それをユーザーインターフェイス、アプリケーション、およびインフラストラクチャコードから分離します。ドメインオブジェクトは、自分自身の表示、自分自身の保存、アプリケーションタスクの管理などの責任を負うことなく、ドメインモデルの表現に集中できます。これにより、モデルは不可欠なビジネス知識を捉え、それを機能させるのに十分なほどリッチで明確なものへと進化するのです。__

ここでの主要な目標は分離です。「Hexagonal Architecture」などの関連するパターンは、ドメインモデル表現が、システムの他の部分への依存や参照を避けるのに役立つことがあります。

### Entities

多くのオブジェクトは、それらの属性は変わることがあるにせよ、ライフサイクルの中で継続性と同一性のスレッドを表しています。

主にオブジェクトを定義づけるものが、その属性ではないことがあります。それらは時間の中を経て、様々な異なる表現で表されたとしても、同一性のスレッドを表します。そのようなオブジェクトは、属性が異なっていても、別のオブジェクトと一致しなければならないことがあります。オブジェクトは同じ属性を持っていても他のオブジェクトと区別されなければならないこともあります。同一性を誤ってしまうと、データが破損する可能性があります。

したがって:

__オブジェクトが、その属性ではなく、その識別子によって区別される場合は、これをモデル内のその定義の中心にします。 クラス定義を単純に保ち、ライフサイクルの継続性と同一性に焦点を当てます。__

__形状や履歴に関係なく、各オブジェクトを区別する方法を定義しましょう。属性値によってオブジェクトを一致させることを要求する要件に注意してください。各オブジェクトに対して、一意であることが保証されているシンボルを添えることで、一意の結果が得られることが保証される操作を定義しましょう。この識別手段は、外部から来たり、システム自身が作成する任意の識別子であったりするが、モデル内の同一性の区別に対応している必要があります。__

__モデルは、同じものであるということがどういうことかを定義しなければなりません。__

(aka Reference Objects)

### Value Objects

オブジェクトはモノの特性を記述したり、計算したりします。

多くのオブジェクトは同一性の概念を持ちません。

エンティティの識別情報を追跡することは不可欠ですが、他のオブジェクトに識別情報を添付すると、システムパフォーマンスが低下し、分析作業が追加され、すべてのオブジェクトを同じように見せることでモデルが混乱する可能性があります。ソフトウェア設計は複雑さを伴う絶え間ない戦いです。特別扱いをするのは必要な場合だけに留めるよう、区別する必要があります。

ただし、このようなカテゴリのオブジェクトを、単に同一性がないものと見なしてしまうと、ツールボックスや語彙に情報があまり追加されません。実際には、これらのオブジェクトは、それぞれ独自の特性、およびモデルに対する独自の意味を持っています。これらは物事を説明するオブジェクトなのです。

Therefore:

__モデルの要素の属性とロジックだけに関心がある場合は、それを値オブジェクトとして分類してください。それ自身が伝える属性値の意味を表現し、それに関連する機能を与えるようにします。値オブジェクトを不変なものとして扱います。すべての操作は、変更可能なステートに依存しない、副作用のない関数にします。値オブジェクトに同一性を与えず、エンティティを維持するのに必要な設計の複雑さを避けてください。__

### Domain Events *

ドメインエキスパートが気にかけていることが起こりました。

エンティティは、そのステートとライフサイクルを規制するルールを追跡する責任を持ちます。しかし、ステート変更の実際の原因を知る必要がある場合、これは通常明示的ではなく、システムがどのような道を辿ったかを説明するのは難しいかもしれません。監査証跡はトレースを可能としますが、通常はプログラム自体のロジックに使用するのには適していません。エンティティの変更履歴があれば以前の状態へアクセスできますが、それらの変更の意味を無視するため、情報の操作は手続き型であり、多くの場合ドメイン層から押し出されます。

分散システムでは、関連する一連の問題が発生します。分散システムのステートは常に完全に一貫性を保つことはできません。集合体は常に内部的に一貫性を保ち、一方で他の変更は非同期的に行います。変更がネットワークのノード全体に伝播するため、順不同・異なるソースから伝わる複数の更新を解決することは困難です。

したがって:

__ドメイン内のアクティビティに関する情報を一連の個別のイベントとしてモデル化します。各イベントをドメインオブジェクトとして表します。これらは、ソフトウェア自体のアクティビティを反映するシステムイベントとは異なりますが、多くの場合、システムイベントは、ドメインイベントへの応答の一部として、またはドメインイベントに関する情報をシステムに伝達する方法として、ドメインイベントに関連付けられます。__

__ドメインイベントは、ドメインモデルの成熟した部分であり、ドメインで発生した何かの表現です。ドメインエキスパートが追跡または通知するイベント、または他のモデルオブジェクトのステート変更に関連するイベントを明示しながら、無関係なドメインアクティビティを無視します。__

分散システムでは、特定のノードが現在認識しているドメインイベントからエンティティのステートを推測できるようにすることで、システム全体に関する完全な情報がなくても一貫性のあるモデルを実現することができます。

ドメインイベントは、過去の何かの記録であるため、通常不変です。 通常、ドメインイベントには、イベントの説明に加えて、イベントが発生した時間のタイムスタンプと、イベントに関係するエンティティのID（一意性）が含まれます。 また、ドメインイベントには多くの場合、イベントがシステムにいつ入力されたか、およびイベントを入力した人のID（一意性）を示す個別のタイムスタンプがあります。 有用な場合、ドメインイベントのIDは、これらのプロパティのセットに基づくことができます。 そのため、例えば、同じイベントの2つのインスタンスがノードに到着した場合、それらは同じものとして認識されます。

### Services

時々、それはモノではありません。

ドメインの一部の概念は、オブジェクトとしてモデル化するのが自然ではありません。必要なドメインの機能の責任をエンティティまたは値に押し付けると、モデルベースのオブジェクトの定義をゆがめたり、無意味で不自然なオブジェクトが増えてしまいます。

したがって:

__ドメイン内の重要なプロセスや変換がエンティティまたは値オブジェクトが責任を持つことが自然ではない場合、サービスとして宣言された、スタンドアロンインターフェイスとしてモデルに操作を追加します。 サービスコントラクト、つまりサービスとの相互作用に関する一連のアサーションを定義します。 （アサーションを参照してください。）これらのアサーションは、特定の有界コンテキストのユビキタス言語で述べてください。 サービスに名前を付けます。これは、ユビキタス言語の一部にもなります。__

### Modules

誰もがモジュールを使用しますが、それらをモデルの一部として扱う人はほとんどいません。コードは、技術的アーキテクチャの側面、開発者の作業割当など、あらゆる種類のカテゴリに分類できます。多くのリファクタリングを行う開発者でさえ、プロジェクトの初期に考案されたモジュールで満足してしまう傾向があります。

結合と凝縮の解説は、関連性と相互作用の配分に基づいて機械的に判断されるため、技術的なメトリックのように聞こえる傾向があります。 それでも、コードはモジュールに分割されるだけでなく、概念にもなります。 人が一度に考えることができる物の数には制限があります（したがって、低い結合度）。 一貫性のないアイデアの断片は、成熟していないアイデアのるつぼと同じくらい理解するのが困難です（したがって、高い凝集度）。

Therefore:

__システムのストーリーを伝えるモジュールを選択し、凝縮した概念のセットを含めます。 ユビキタス言語の一部となるモジュール名を付けます。 モジュールはモデルの一部であり、その名前はドメインへの洞察を反映する必要があります。__

__概念を解きほぐすためにモデルを変更する方策、または要素を意味のある方法でまとめるモジュールの基礎となりうる概念を見落としてないかを追求することで、モジュール間の低い結合がもたらされます。概念の意味を独立して理解・推論できるような低結合を求めます。 高レベルのドメイン概念に従って区切られ、対応するコードも同様に分離されるまで、モデルを改良します。__

(aka Packages)

### Aggregates

複雑な関連付けを持つモデル内のオブジェクトへの変更の一貫性を保証することは困難です。 オブジェクトは独自の内部一貫性状態を維持することになっていますが、概念的には構成要素である他のオブジェクトの変更によって盲目的になる可能性があります。 注意深いデータベースロックスキームにより、複数のユーザーが互いに無意味に干渉し、システムが使用できなくなる可能性があります。 オブジェクトを複数のサーバーに分散するとき、または非同期トランザクションを設計するときに、同様の問題が発生します。

Therefore:

__エンティティと値オブジェクトをクラスターに集約し、それぞれの周囲の境界を定義します。 各集約のルートとなるエンティティを1つ選択し、外部オブジェクトがルートへの参照のみを保持できるようにします（単一操作内でのみ使用するために渡される内部メンバーへの参照）。 集合体全体のプロパティと不変条件を定義し、ルートまたは指定されたフレームワークメカニズムに施行責任を与えます。__

同じ集約境界を使用して、トランザクションとディストリビューションを管理します。

集約境界内で、整合性ルールを同期的に適用します。 境界を越えて、非同期的に更新を処理します。

1つのサーバーに集約をまとめます。 異なる集約をノード間で分散できるようにします。

これらの設計上の決断が集約境界によってうまく導かれない場合は、モデルを再検討してください。 ドメインシナリオは重要な新しい洞察を示唆していますか？ 多くの場合、このような変更を行うことで、モデルの表現力と柔軟性が向上し、トランザクションおよびディストリビューションの問題が解決します。

### Repositories

_ユビキタス言語で表現された集約へのクエリアクセス。_

物事を見つけるためだけに横断的な関連付けを使うことが拡散されると、モデルが混乱します。成熟したモデルでは、クエリはしばしばドメインの概念を表現します。それでも、クエリは問題を引き起こす可能性があります。

データベースアクセスインフラストラクチャを適用することはたいてい技術的に複雑であるため、クライアントコードはすぐに沈められ、開発者はドメインレイヤーを簡略化して伝えることになり、モデルは無関係になります。

クエリフレームワークは、その技術的な複雑さのほとんどをカプセル化し、開発者がデータベースから必要なデータをより自動化または宣言的な方法で引き出すことを可能にしますが、それは問題の一部を解決するだけです。

制約のないクエリは、オブジェクトから特定のフィールドを取り出したり、カプセル化を破ったり、集約の内部からいくつかの特定のオブジェクトをインスタンス化し、集約ルートを隠蔽して、これらのオブジェクトがドメインモデルのルールを実施できないようにします。 ドメインロジックはクエリとアプリケーションレイヤーコードに移行し、エンティティと値オブジェクトは単なるデータコンテナーになります。

Therefore:

__グローバルアクセスが必要な集約の各タイプについて、その集約のルートタイプのすべてのオブジェクトのメモリ内コレクションのように扱うことができるようなサービスを作成します。既知のグローバルインターフェイスを介してアクセスを設定します。データストア内のデータの実際の挿入・削除をカプセル化するため、オブジェクトを追加・削除するメソッドを提供します。ドメインの専門家にとって意味のある基準に基づいてオブジェクトを選択（select）するメソッドを提供します。 完全にインスタンス化されたオブジェクトまたは属性値が基準を満たすオブジェクトのコレクションを返すことにより、実際のストレージとクエリテクノロジーをカプセル化します。または、完全にインスタンス化された集計を怠zyに見せかけるプロキシを返します。 実際に直接アクセスする必要がある集約ルートに対してのみリポジトリを提供します。 アプリケーションロジックをモデルに集中させ、すべてのオブジェクトストレージとリポジトリへのアクセスを委任します。__

### Factories

内部的に一貫性のある全体的な集約、または大きな値のオブジェクトの作成が複雑になったり、内部構造が明らかになりすぎたりすると、工場はカプセル化を提供します。
オブジェクトの作成はそれ自体が主要な操作になりますが、複雑なアセンブリ操作は作成されたオブジェクトの責任に適合しません。 このような責任を組み合わせることで、理解しにくい不格好なデザインを生み出す可能性があります。 クライアントを直接構築すると、クライアントの設計が混乱し、組み立てられたオブジェクトまたは集合体のカプセル化が破られ、作成されたオブジェクトの実装にクライアントが過度に結合されます。

Therefore:

__複雑なオブジェクトと集合体のインスタンスを作成する責任を別のオブジェクトに移します。これは、ドメインモデルには責任を持たない可能性がありますが、それでもドメイン設計の一部です。 すべての複雑なアセンブリをカプセル化し、インスタンス化されるオブジェクトの具体的なクラスをクライアントが参照する必要のないインターフェイスを提供します。 集合体全体をピースとして作成し、その不変条件を適用します。 おそらくビルダーで要素を組み立てた後、複雑な値オブジェクトをピースとして作成します。__
