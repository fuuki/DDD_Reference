## IV.Context Mapping for Strategic Design

#### bounded context

特定のモデルが定義され適用可能な境界の説明（通常はサブシステム、または特定のチームの作業）。

#### upstream-downstream

「上流」グループの行動が「下流」グループのプロジェクトの成功に影響を与えるが、下流の行動が上流のプロジェクトに大きな影響を与えない2つのグループ間の関係。 （たとえば、2つの都市が同じ川沿いにある場合、上流の都市の汚染は主に下流の都市に影響を与えます。）

上流のチームは下流のチームの運命とは無関係に成功するかもしれない。

#### mutually dependent

2つの別々のコンテキストのソフトウェア開発プロジェクトが成功と見なされるためには、両方が提供される必要があるという状況。（2つのシステムがお互いの情報や機能に依存している場合 - 私たちが一般的に避けようとしていること - 自然にそれらを相互依存として構築するプロジェクトを見ます。しかしシステム依存が一方向のみを走る相互依存プロジェクトもあります。 依存型システムとそのシステムとの統合がなければ、依存型システムにはほとんど価値がありません - おそらくこれが唯一の使用場所であるため、依存型システムの提供に失敗すると、両方のプロジェクトが失敗することになります。)

#### free

他のコンテキストでの開発作業の方向、成功、または失敗が提供にほとんど影響しないソフトウェア開発コンテキスト。

### Context Map

戦略を描くためには、私たちのプロジェクトと私たちが統合している他の人とにまたがる現実的で大規模なモデル開発の見方が必要です。

グローバルな見解がない場合、個々の境界のある文脈はいくつかの問題を残します。 他のモデルのコンテキストはまだ曖昧で流動的かもしれません。

他のチームの人々はコンテキストの境界をあまり意識しておらず、知らないうちに境界をぼかしたり相互接続を複雑にしたりするような変更を加えるでしょう。 異なるコンテキスト間で接続を確立する必要がある場合、それらは互いを傷つけ合う傾向があります。

境界線がはっきりしていても、他の文脈との関係は、実現可能なモデルの性質または変化のペースに制約を課します。 これらの制約は、主に非技術的なチャネルを通じて明らかになり、それらが影響を及ぼしている設計の判断に関連させるのが難しいことがあるでしょう。

Therefore:

__プロジェクトで機能している各モデルを識別し、その境界のあるコンテキストを定義します。 これには、非オブジェクト指向サブシステムの暗黙のモデルも含まれます。 それぞれの境界のある文脈に名前を付け、その名前をユビキタス言語の一部にします。__

__モデル間の接点を説明し、コミュニケーションのための明示的な翻訳を概説し、共有、孤立メカニズム、影響力のレベルを強調する。__

__既存の地形をマッピングします。 後に変容するでしょう。__

この地図は、現実的なデザイン戦略の基礎になりうるものです。

次のページでは、関係の特徴付けをより具体的にし、境界のある文脈間の関係のコモンパターンのセットを示します。

### Partnership *

2つのコンテキストで共にチームが成功または失敗すると、協力的な関係が頻繁に出現します。

別々のコンテキストで相互に依存するサブシステムを適切に調整しないと、両方のプロジェクトで配信エラーが発生します。 1つのシステムに重要な機能がないと、他のシステムが配信不能になる可能性があります。 他のサブシステムの開発者の期待に合わないインターフェースは、統合に失敗する可能性があります。 相互に同意されたインターフェースは、クライアントシステムの開発を遅らせるほど使用が困難であるか、サーバーサブシステムの開発を遅らせるほど実装が困難であることが判明する場合があります。 失敗すると、両方のプロジェクトが停止します。

Therefore:

__2つのコンテキストのいずれかで開発が失敗すると、両方の配信が失敗する場合、2つのコンテキストを担当するチーム間のパートナーシップを構築します。 開発の統合された計画と統合の共同管理のためのプロセスを確立します。__

__チームは、両方のシステムの開発ニーズに対応するために、インターフェースの進化に協力する必要があります。 相互依存機能は、同じリリースで完了するようにスケジュールする必要があります。__

ほとんどの場合、開発者が他のサブシステムのモデルを詳細に理解する必要はありませんが、プロジェクトの計画を調整する必要があります。 あるコンテキストでの開発が障害に直面した場合、どちらのコンテキストも過度に妥協しない迅速な設計ソリューションを見つけるために、問題の共同調査が求められます。

また、統合を管理するには明確なプロセスが必要です。 たとえば、インターフェイスがクライアントシステムの期待を満たしていることを証明する特別なテストスイートを定義できます。これは、サーバーシステムでの継続的な統合の一部として実行できます。

### Shared Kernel

_モデルの一部が関連するコードと共有されていると非常に密接な相互依存関係にあり、設計作業に影響を与えたり、それをひそかに傷つける可能性があります。_

機能統合が制限されている場合、大規模コンテキストの継続的統合のオーバーヘッドは高すぎると見なされる可能性があります。 これは、チームが継続的な統合を維持するためのスキルや政治組織を持っていない場合、または単一のチームが大きすぎて扱いにくい場合に特に当てはまります。 そのため、境界のあるコンテキストを別々に定義し、複数のチームを結成しましょう。

密接に関連したアプリケーションに取り組んでいる別々の、調整されていないチームはしばらくの間レースを進めることができますが、彼らが作り出すものは噛み合わないかもしれません。 パートナーチームでさえ、翻訳レイヤと後付けに多大な時間を費やすことになり、その間に努力が重複し、一般的なユビキタス言語の利点を失う可能性があります。

Therefore:

__チームがすすんで共有するようなドメインモデルのサブセットを明示的な境界で指定します。 このカーネルを小さくしてください。__

__この境界内に、モデルのこのサブセットとともに、モデルのその部分に関連するコードまたはデータベース設計のサブセットを含めます。 この明示的に共有されたものには特別な地位があり、他のチームと相談しないで変更するべきではありません。__

カーネルモデルを厳密に保ち、チームのユビキタス言語を調整する継続的な統合プロセスを定義します。 機能システムを頻繁に統合しますが、チーム内での継続的統合のペースよりはやや少ないです。

### Customer/Supplier Development

_2つのチームがアップストリームとダウンストリームの関係にあり、アップストリームのチームがダウンストリームのチームの運命とは無関係に成功する可能性がある場合、ダウンストリームのニーズはさまざまな方法で対処されるようになります。_

ダウンストリームのチームは、アップストリームが優先されるために無力化されることがあります。 つまり、アップストリームのチームは抑制されるかもしれず、ダウンストリームのシステムを壊すことを心配します。 ダウンストリームチームの問題は、複雑な承認プロセスを伴う面倒な変更依頼手順によっては改善されません。また、 ダウンストリームチームが変更に対する拒否権を持っている場合、アップストリームチームの自由な開発は阻止されます。

Therefore:

__2つのチームの間に明確なカスタマー／サプライヤの関係を確立します。これは、下流の優先順位が上流の計画に組み込まれることを意味します。 全員がコミットメントとスケジュールを理解できるように、下流の要件についてタスクを交渉し予算を組みます。__

アジャイルチームは、計画セッションにおいて、下流チームが上流チームに対してカスタマーの役割を果たすようにできます。 共同開発された自動受け入れテストは、上流から期待されるインタフェースを検証することができます。 これらのテストをアップストリームチームのテストスイートに追加し、継続的な統合の一環として実行することで、ダウンストリームの副作用を心配せずにアップストリームチームが変更を加えることができます。

### Conformist

2つの開発チームが、上流チームが下流チームのニーズを満たす動機を持たない上流/下流関係にある場合、下流チームは無力です。 利他主義は上流の開発者が約束をするように動機付けるかもしれませんが、それらが実現されることはまずありません。 これらの善意を信じることで、川下のチームは利用できなくなる機能に基づいて計画を立てるようになります。 下流のプロジェクトは、チームが最終的にそれが与えられたものを我慢して受け入れて学ぶまで遅れるでしょう。 下流チームのニーズに合わせたインターフェースはカードにはありません。

Therefore:

__上流チームのモデルに忠実に従うことで、境界のあるコンテキスト間の翻訳の複雑さを排除します。 これは下流の設計者のスタイルを悩ませ、おそらくアプリケーションにとって理想的なモデルを生み出さないでしょうが、適合性を選択することは統合を非常に単純化します。 また、上流のチームとユビキタス言語を共有します。 上流は運転席にあるので、彼らにとってコミュニケーションを容易にするのは良いことです。 利他主義は、彼らにあなたと情報を共有させるのに十分かもしれません。__

### Anticorruption Layer

うまく設計された境界のあるコンテキストを協調的なチームと橋渡しするとき、翻訳レイヤは単純でエレガントなものになることがあります。 しかし、制御やコミュニケーションが、共有されたカーネル、パートナー、あるいはカスタマー/サプライヤの関係をやめるのに十分でない場合、翻訳はより複雑になります。 翻訳レイヤはより防御的なトーンを帯びます。

上流システムとの大きなインターフェイスは、最終的に下流モデルの意図を完全に圧倒し、アドホックな方法で他のシステムのモデルに似るように変更されます。 レガシーシステムのモデルは通常弱く（泥の大きな球ではない場合）、明確に設計された例外でさえ、現在のプロジェクトのニーズに合わない場合があり、上流モデルに準拠することは実用的ではありません。 それでも、統合は非常に価値があり、下流プロジェクトに必要とされることさえあります。

Therefore:

__下流クライアントとして、独自のドメインモデルに関して、システムに上流システムの機能を提供する分離層を作成します。 この層は、既存のインターフェースを介して他のシステムと通信し、他のシステムをほとんどまたはまったく変更する必要がありません。 内部的に、レイヤーは必要に応じて2つのモデル間で一方向または両方向に移動します。__

### Open-host Service

通常、有界コンテキストごとに、コンテキストの外部にある統合する必要のある各コンポーネントの翻訳レイヤーを定義します。 統合が1回限りである場合、各外部システムに変換レイヤーを挿入するこのアプローチは、最小限のコストでモデルの破損を回避します。 しかし、サブシステムの需要が高い場合、より柔軟なアプローチが必要になる場合があります。

サブシステムを他の多くのシステムと統合する必要がある場合、それぞれの翻訳者をカスタマイズするとチームが動かなくなる可能性があります。 メンテナンスがますます必要になり、変更が行われたときの心配が増えています。

Therefore:

__サブシステムへのアクセスを一連のサービスとして提供するプロトコルを定義します。 あなたと統合する必要があるすべての人が使用できるように、プロトコルをオープンにします。 単一のチームに特異なニーズがある場合を除き、プロトコルを強化および拡張して、新しい統合要件を処理します。 次に、1回限りの翻訳を使用して、その特殊なケースのプロトコルを拡張し、共有プロトコルがシンプルで一貫性を保つようにします。__

これにより、サービスのプロバイダーが上流の位置に配置されます。 各クライアントは下流であり、通常、それらの一部はコンフォーマストであり、一部は腐敗防止レイヤーを構築します。 オープンホストサービスを持つコンテキストは、そのクライアント以外のコンテキストと何らかの関係を持つ場合があります。

### Published Language

_2つの境界のあるコンテキストのモデル間の翻訳には、共通の言語が必要です。_

既存のドメインモデルとの間の直接変換は、良い解決策ではない場合があります。これらのモデルは、過度に複雑であるか、十分に因子化されていない場合があります。それらはおそらく文書化されていません。1つをデータ交換言語として使用すると、基本的に凍結され、新しい開発ニーズに対応できなくなります。

Therefore:

__必要なドメイン情報をコミュニケーションの共通媒体として表現できる、十分に文書化された共有言語を使用し、必要に応じてその言語に変換したり、その言語から変換したりします。__

多くの業界では、データ交換標準の形式で公開言語を確立しています。 プロジェクトチームは、組織内で使用するために独自に開発したりもします。

公開された言語は、多くの場合、オープンホストサービスと組み合わされます。

### Separate Ways

要件の定義に関しては、冷酷でなければなりません。 2つの機能セットに重要な関係がない場合は、それらを完全に切り離すことができます。

統合のコストは常に高いですが、メリットは小さいことが多いです。

Therefore:

__制限されたコンテキストを宣言して、他のユーザーとまったく接続しないようにします。これにより、開発者はこの小さなスコープ内でシンプルで専門的なソリューションを見つけることができます。__

### Big Ball of Mud *

既存のソフトウェアシステムを調査し、明確なモデルが定義された境界内でどのように適用されているかを理解しようとすると、モデルが混在し境界が一貫していないシステムの一部、多くの場合大きなシステムを見つけます。

単に境界が存在しないシステムでモデルのコンテキスト境界を記述しようとすると、行き詰まってしまいがちです。

明確に定義されたコンテキストの境界は、知的選択と社会的力の結果としてのみ出現します（システムを作成する人々は、常にこれらの原因を常に意識していたわけではありませんが）。 これらの要因が存在しない、または消滅すると、複数の概念システムが混ざり合い、定義と規則があいまいまたは矛盾するようになります。 機能が追加されると、システムは条件付きロジックによって機能するようになります。 依存関係はソフトウェアを横断します。 原因と結果の追跡がますます困難になります。 最終的に、ソフトウェアは大きな泥の塊に固まります。

泥の大きな玉は実際にはいくつかの状況では非常に実用的です（Foote and Yoderのオリジナル記事で説明されています）が、有用なモデルに必要な繊細さと精度をほぼ完全に妨害します。

Therefore:

__混乱全体の周りに境界を描き、それを泥の大きなボールに指定します。 このコンテキスト内で高度なモデリングを適用しようとしないでください。 そのようなシステムが他のコンテキストにスプロールする傾向に注意してください。__

(see http://www.laputan.org/mud/mud.html. Brian Foote and Joseph Yoder)
