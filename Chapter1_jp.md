## I. Putting the Model to Work

ドメイン駆動設計は、複雑なソフトウェアを開発するためのアプローチであり、その中で私たちは、

1. コアドメインに焦点を当てます。
2. ドメイン実行者とソフトウェア実行者の創造的なコラボレーションでモデルを探ります。
3. 明示的に限定された文脈の中でユビキタス言語を話します。

この3点のDDDの要約にでてくる用語は、この小冊子の中で定義されています。

モデリング作業は多くのプロジェクトで行われますが、実際に大きな利益を享受することなく終わってしまうのが大半です。 DDDのパターンは、モデリングにより劇的な利益がもたらされたプロジェクトから成功したプラクティスを抽出します。 まとめると、彼らは、モデリングとソフトウェア開発に対して、細部から高度なビジョンまで、まったく異なるアプローチを提示します。厳密なモデリング規約は、技術者以外の人々と協力してモデルを自由に探索することとバランスが取れていなければなりません。成功するには戦術と戦略を組み合わせる必要があり、DDDは戦術的設計と戦略的設計の両方からアプローチを仕掛けます。

### Bounded Context

大規模プロジェクトでは複数のモデルが使用されています。それらは多くの理由で出現します。2つのサブシステムがあるときは、一般に、非常に異なるユーザーコミュニティにサービスを提供しており、そこでは、ジョブが異なるので、異なるモデルを使用すると便利な場合があります。 しかし、チームが独立してに活動するために、コミュニケーションが欠如し、同じ問題を別々の方法で解決していることがあります。 ツールセットも異なる場合があります。つまり、プログラムコードを共有することはできません。

複数のモデルは避けられませんが、異なるモデルに基づくコードを組み合わせると、ソフトウェアはバグが多くなり、信頼性が低くなり、理解が困難になります。チームメンバー間のコミュニケーションは混乱します。モデルが適用されるべきでないコンテキストがどのようなものかは、明確でないことが多いです。

モデル表現は、他のフレーズと同様に、コンテキスト内でのみ意味を持ちます。

したがって:

__モデルが適用されるコンテキストを明示的に定義しましょう。 チーム編成、アプリケーションの特定部分内での使用、およびコードベースやデータベーススキーマなどの物理的表現に関して、境界を明示的に設定します。モデルの概念と用語をこれらの範囲内で厳密に一致させるために継続的インテグレーションを適用しますが、外部の問題には邪魔されたり、混乱させられたりしてはいけません。コンテキスト内で単一の開発プロセスを標準化します。他の場所で使用する必要はありません。__

### Ubiquitous Language

```
For first you write a sentence,
And then you chop it small;
Then mix the bits, and sort them out Just as they chance to fall:
The order of the phrases makes
No difference at all.
```

—_Lewis Carroll, “Poeta Fit, Non Nascitur”_

しなやかで知識豊富なデザインを作成するには、用途の広い、共有されたチーム言語、およびソフトウェアプロジェクトではあまり行われない、言語による活発な試みが必要です。

単一の有界コンテキストの中においては、洗練されたモデリングを適用するための努力を怠ると、言語は破壊されてしまうでしょう。 モデルがチームの技術メンバー用のUMLダイアグラムを描画するためだけに使用されている場合、それはDDDの心臓部である創造的なコラボレーションに貢献していません。

ドメインエキスパートは職業語を使用しますが、技術チームのメンバーは設計の観点からドメインを議論するために独自の言語を使用しています。 日々の議論の用語は、コード（最終的にはソフトウェアプロジェクトの最も重要な製品）に埋め込まれている用語から切り離されています。 そして同一人物でさえも、話す言葉と文章で異なる言語を使用しているため、ドメインの最も鋭敏な表現は瞬間的に現れ、コードや文章でさえとらえられないことがよくあります。

翻訳はコミュニケーションを鈍らせ、知識の貧血をひどくします。

さらに、これらの言語はすべてのニーズを満たすものではない方言なので、共通の言語にはなれません。

ドメインエキスパートは、ドメインの解釈を教えるには扱いにくい・不適切な用語・構造に異を唱えるべきです。 一方、開発者は曖昧さや矛盾に注意するべきです。

あなたがシステムについて話すときと同じようにモデルを扱ってください。モデルが許容する方法で概念を結合することで、モデルの要素と相互作用を用いてシナリオを声高に説明してください。あなたが言わなければならないことをより簡単に言う方法を見つけて、そしてそれらの新しい考えをダイアグラムとコードに落とし込んでください。

ユビキタス言語では、モデルは単なる設計の成果物ではありません。それは開発者とドメインエキスパートが共に活動するために不可欠なものになります。

したがって:

__モデルを言語のバックボーンとして使用しましょう。チーム内およびコード内のすべてのコミュニケーションにおいて、その言語を執拗に行使することをチームに約束します。有界コンテキストの中では、ダイアグラム、文章、そして特に会話で同じ言語を使用してください。__

__言語の変更はモデルの変更であることを認識してください。__

__新しいモデルを反映する新しい表現を試行し、困難に立ち向かいましょう。そうしたら、コードをリファクタリングして、クラス、メソッド、およびモジュールの名前を新しいモデルに合わせます。それが普通の言葉の意味として使われるようになったとき、会話の中の用語についての混乱が解決されます。__

### Continuous Integration

_有界コンテキストが一度定義されたら、それを健全に保つ必要があります。_

複数の人が同じ有界コンテキストで作業をしている場合、モデルが断片化する傾向が強いです。チームが大きくなればなるほど、問題も大きくなりますが、わずか3〜4人のチームであっても深刻な問題に遭遇する可能性はあります。しかしながら、システムをより小さなコンテキストに分割すると、徐々に整合性と一貫性の価値が失われます。

したがって:

__すべてのコードおよびその他の実装成果物を頻繁にマージするプロセスを設け、このとき、断片化を迅速に知らせる自動テストを導入しましょう。概念がさまざまな人々の頭の中で進化していくのに合わせて、モデルの共通の見解を煮詰めながらユビキタス言語をしっかりと成長させましょう。__

### Model-Driven Design

_コードを基礎となるモデルに密接に関連付けることで、コードに意味が与えられ、モデルが適切になります。_

設計、またはその中心部分がドメインモデルにマッピングされていない場合、そのモデルはほとんど価値がなく、ソフトウェアの正当性は疑わしいものとなります。 同時に、モデルと設計機能との間の複雑なマッピングは理解するのが難しく、実際には設計が変わるにつれて維持するのが不可能になります。読解と設計の間に致命的な格差が発生するため、これらの各活動で得られた気づきが他の活動で活用されることはありません。

設計で使用される用語と、与えられた基本的な責任をモデルから抽出しましょう。コードはモデルの表現になるので、コードへの変更はモデルへの変更になるかもしれません。その影響はプロジェクトのその他の活動へも波及させなければなりません。

実装をモデルに奴隷的に結び付けるには、通常、オブジェクト指向プログラミングなどのモデリングパラダイムをサポートするソフトウェア開発ツールと言語を必要とします。

したがって:

__マッピングを明白にするため、ソフトウェアシステムのある部分を設計するときは、ドメインモデルを極めて逐語的に反映するようにしましょう。モデルを見直して、ドメインに対するより深い洞察を反映させようとしながらも、ソフトウェアでより自然に実装されるようにモデルを変更します。流暢なユビキタス言語をサポートすることに加えて、両方の目的をうまく果たす単一のモデルが必要です。__

### Hands-on Modelers

コードを作成した人々がモデルに対して責任を感じない、またはモデルをアプリケーションに対して機能させる方法を理解していない場合、モデルはソフトウェアとは無関係です。開発者がコードを変更することでモデルが変更されることを認識していない場合、リファクタリングによってモデルが強化されるどころか、弱められるでしょう。 一方、モデラーが実装プロセスから切り離されると、モデラーは実装の制約をすぐに忘れてしまうか、一切感じ取ることが無いかとなります。モデル駆動設計の基本的な制約 -- モデルが効果的な実装をサポートし、ドメインへの重要な洞察を抽象化する -- は、大半がなくなり、結果として得られるモデルは実用的ではなくなります。 最後に、もし分業によってモデル駆動型デザインのコーディングの微妙な部分を伝えるようなコラボレーションが妨げられれば、熟練したデザイナーの知識とスキルが他の開発者に伝えられることはないでしょう。

したがって:

__モデルに関与している技術担当者は全員、プロジェクトでの主要な役割が何であれ、コードに触れる時間を確保しなければなりません。コードを変更する責任がある人は全員、コードを通してモデルを表現する方法を学ばなければなりません。 すべての開発者は、程度はさておき、モデルに関する議論に参加してドメインエキスパートと接触する必要があります。さまざまな方法で関与する人々は、ユビキタス言語を介してモデルのアイデアをダイナミックに交換しながら、コードに触れる人々を意識的に引き込ませる必要があります。__

### Refactoring Toward Deeper Insight

論証された基本的な構成要素を一貫した言語とともに使用することで、開発作業にある種の正気性がもたらされます。残った課題は、ドメインエキスパートの関心ごとの細かい部分まで捉え、かつ実用的な設計を推進することができる、斬新なモデルを実際に見つけることです。深いモデルとは、表面的なものから抜け出して本質的なものを捉えるモデルです。これにより、ソフトウェアはドメインの専門家が考える方法とより調和し、ユーザーのニーズにより即応するようになります。

伝統的に、リファクタリングは技術的な動機から生まれる、コード変換の観点から説明されています。しかし、リファクタリングは、ドメインへの洞察力とそれに対応するモデルの洗練またはコード内でのその表現によっても動機付けられます。

洗練されたドメインモデルは、リファクタリングの反復プロセスを通して発展された場合にしか役に立つことはないでしょう。そこには、ドメインについて学ぶことに興味を持っている開発者とドメインエキスパートの密接な関わりが含まれます。
